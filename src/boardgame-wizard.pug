extends /layouts/default

block beforehtml
  - const title = '神機妙算記分板'

block style
  meta(property="fb:app_id", content="2133031763635285")
  meta(property="og:description", content="桌遊「神機妙算」的記分板。")
  meta(property="og:image:height", content="640")
  meta(property="og:image:width", content="1280")
  meta(property="og:image", content="https://i.imgur.com/nYPObP2.jpg")
  meta(property="og:locale", content="zh_TW")
  meta(property="og:site_name", content="筆記國度")
  meta(property="og:title", content=title)
  meta(property="og:type", content="website")
  meta(property="og:url", content="https://taichunmin.idv.tw/pug/boardgame-wizard.html")
  style
    :sass
      [v-cloak]
        display: none
      #app
        .dropdown-menu
          padding: 0

block content
  #app.container-fluid.text-monospace(v-cloak)
    h1.text-center.my-3= title
    .card.mb-3
      //- 頁面選單
      .card-header
        ul.nav.nav-tabs.card-header-tabs
          li.nav-item(v-for="pName, pId in {setting: '設定', input: '記錄', scores: '得分', rule: '規則'}")
            a.nav-link(href="#", :class="{active: i.page === pId}", @click="i.page = pId") {{ pName }}
      //- 設定頁面
      .card-body.px-3(v-if="i.page == 'setting'")
        .row.px-2
          .col.px-0.mx-2
            .dropdown
              button.btn.btn-block.btn-primary.dropdown-toggle(type="button", data-toggle="dropdown") #[span.fa.fa-fw.fa-male] {{ i.players.length }} 人&nbsp;
              .dropdown-menu
                button.dropdown-item(type="button", v-for="n in [3,4,5,6]", :class="{active: n === i.players.length}", @click="n !== i.players.length && setPlayers(n)") {{ n }} 人
          .col.px-0.mx-2
            button.btn.btn-danger.btn-block(type="button", @click="setPlayers(i.players.length)") #[span.fa.fa-fw.fa-trash-o] 清除資料
        .input-group.input-group-sm.mt-3(v-for="player, playerId in i.players", :key="playerId")
          .input-group-prepend
            .input-group-text 玩家 {{ playerId + 1 }} 暱稱
          input.form-control.form-control-sm(type="text", v-model="player.name")
          .input-group-append(v-if="playerId > 0")
            button.btn.btn-outline-secondary(type="button", @click="playerSwapWithNext(playerId-1)")
              i.fa.fa-fw.fa-arrow-up
      //- 紀錄頁面
      table.table.table-bordered.text-nowrap.text-center.mb-0(v-if="i.page == 'input' && !!roundMax")
        tr
          th.p-1(colspan="2") {{ i.roundCur + 1 }}/{{ roundMax }}
          th.p-1
            span.pr-2.align-middle 預測
            span.badge.badge-info {{ predictsSum[i.roundCur] }}
          th.p-1
            span.pr-2.align-middle 結果
            span.badge(:class="(resultsSum[i.roundCur] === i.roundCur + 1) ? 'badge-success' : 'badge-danger'") {{ resultsSum[i.roundCur] }}
        tr(v-for="player, playerId in i.players")
          td.p-2(:class="playerId === dealer ? 'bg-success text-white' : ''") {{ player.name }}
          td.p-2 {{ playersScore[playerId] }}
          template(v-for="round in [ player.rounds[i.roundCur] ]")
            td.p-1
              .dropdown
                button.btn.btn-sm.btn-block.btn-outline-info.dropdown-toggle(type="button", data-toggle="dropdown") 預測 {{ round.predict }} 墩
                .dropdown-menu.dropdown-menu-right
                  button.btn-sm.dropdown-item(type="button", v-for="n in _.range(i.roundCur + 2)", :class="{ active: n === round.predict }", @click="round.predict = n") 預測 {{ n }} 墩
            td.p-1
              .dropdown
                button.btn.btn-sm.btn-block.btn-outline-success.dropdown-toggle(type="button", data-toggle="dropdown") 吃到 {{ round.result }} 墩
                .dropdown-menu.dropdown-menu-right
                  button.btn-sm.dropdown-item(type="button", v-for="n in _.range(i.roundCur + 2)", :class="{ active: n === round.result }", @click="round.result = n") 吃到 {{ n }} 墩
      .card-body.py-2.px-3(v-if="i.page == 'input'")
        .row.px-2
          .col.px-0.mx-2
            button.btn.btn-block.btn-outline-secondary(type="button", :disabled="i.roundCur <= 0", @click="i.roundCur--") #[span.fa.fa-arrow-left] 上一輪
          .col.px-0.mx-2
            button.btn.btn-block(type="button", :disabled="i.roundCur >= roundMax - 1", @click="i.roundCur++", :class="'btn-outline' + inputResultColor") #[span.fa.fa-arrow-right] 下一輪
      //- 得分頁面
      .table-responsive(v-if="i.page == 'scores' && !!roundMax")
        table.table.table-bordered.table-sm.mb-0.text-center.text-nowrap#result-table
          tr
            th.align-bottom #
            th(v-for="player, playerId in i.players")
              span.badge.badge-primary {{ playersScore[playerId] }}
              br
              span {{ player.name }}
          tr(v-for="roundId in roundMax", :key="roundId")
            th {{ roundId }}
            td(v-for="player in i.players")
              template(v-if="roundsEnable[roundId-1]", v-for="round in [_.get(player, ['rounds', roundId-1])]")
                span.round-score.align-middle(v-for="score in [calculatePlayerRoundScore(round)]", :class="score > 0 ? 'text-success' : 'text-danger'") {{ score }}
      //- 規則頁面
      .card-body.p-2.border-0(v-if="i.page == 'rule'")
        img.mb-3.d-block.mx-auto.img-fluid(src="https://i.imgur.com/70Y0eOD.jpg")
        h3 遊戲背景
        p 很久很久以前，在巨石陣裡還有知名魔法學院的時代，魔法學徒們從事許多活動來訓練和琢磨他們的魔力。其中一個活動就是玩這個叫做「神機妙算」的紙牌遊戲，來發展和強化他們的預知天賦。
        p 在數千年後，這些訓練巫師的方法已經失傳。直到知名的德國考古學家 Horold Eitel 博士從巨石陣的石柱下挖掘出地窖，在裡面發現古老羊皮紙卷軸後，才讓「神機妙算」這個紙牌遊戲，重見天日。雖然紙牌中更深層更奧秘的意義可能已經失傳，但藉由重繪這些古老的圖像，及重述那古老卷軸上的規則，在此為您呈現這個充滿挑戰性的遊戲。
        h3 遊戲配件
        p 60 張角色牌，1 本真實之書（計分表），1 張羊皮紙（規則）。
        h3 遊戲目標
        p 學徒們必須正確地預測他們每輪遊戲將贏到的墩數，如果預測正確的話，就能得到經驗分數。在一回合中，每位玩家輪流出一張牌，正面朝上地置於桌面中央，這些牌稱為一墩。在遊戲結束時，得到最多經驗總分的人贏得遊戲，並且升級為智者巫師。
        h3 發牌階段
        p {{ i.players.length }} 人遊戲共有 {{ _.inRange(i.players.length, 3, 7) ? (60 / i.players.length) : 0 }} 輪。 每輪由一個人順時針輪流作為發牌玩家，第 1 輪每人 1 張牌、第 2 輪每人 2 張牌…依此類推，發牌玩家需要先把牌發給自己。
        h3 王牌花色
        p 沒發完的牌正面朝下放置於桌面中央，翻開最上面的一張牌，這張牌的花色就是這輪的王牌花色。 若最上面的牌為 Z，則由發牌玩家決定本輪的王牌花色，若最上面的牌為 N 或是最後一輪時，以「沒有王牌花色」進行。
        h3 開始預言
        p 在所有玩家看過自己的牌後，由發牌玩家開始，所有玩家依照順時針預測本輪會贏得幾墩，需要有人將所有玩家的預測紀錄於本記分板。
        h3 爭奪吃墩
        p 所有人都預測完後，就進入出牌階段，每次由本輪吃到上一墩的玩家先發，若是本輪第一次出牌則由發牌者先發。
        p 其他玩家必須順時針依序打出一張與先發者同花色的牌（本墩的花色），如果沒有同花色的牌，才能夠打出王牌花色（切牌）或其他花色的牌（墊牌）。
        p 注意：玩家隨時可以打出特殊牌 Z 或 N，不論其手上有沒有跟本墩花色一樣的牌。
        p 注意：若先發者打出巫師牌 Z，則其他人可以不受限制打出任何一張牌（包括 Z 和 N）。
        p 注意：若先發者打出小丑牌 N，則由下一家出牌決定本墩的花色。 若下一家又打出小丑牌 N，則再由下一家出牌決定。
        p
          | 在所有玩家都出一張牌以後，牌最大的玩家吃到這一墩，並且把這一墩的牌收好放到自己面前，牌的大小為：
          ol
            li 若有人出巫師牌 Z，則第一個出 Z 的人贏得此墩。
            li 若沒人出 Z，則打出王牌花色且點數最大的玩家贏得此墩（1 最小 13 最大）。
            li 若沒人出王牌花色，則打出本墩的花色且點數最大的玩家贏得此墩（1 最小 13 最大）。
            li 若所有人都出小丑牌 N，則第一個出 N 的人贏得此墩。
        h3 獲得分數
        p 當本輪的手牌全部打完後，本輪結束，並且將本輪每個人所吃到的墩數紀錄於本記分板。
        p
          | 遊戲計分的方式為：
          ul
            li 若該輪預測正確的玩家，贏得的每一墩都會得到 10 分，並且再額外獲得 20 分。
            li 若該輪預測錯誤的玩家，每多（少）贏到一墩，就扣除 10 分。
        p 玩家每輪所獲得的分數加總即為總分，總分最多的人獲勝。
        h3 自製桌遊
        p 材料：兩副一樣的撲克牌及筆。
        p.mb-0 做法：為了講解方便，在此將撲克牌分別以 A 和 B 表示。從撲克牌 B 中挑出 2 的牌，於牌的左上、中間及右下寫上 N，然後從撲克牌 B 中挑出 4 的牌，於牌的左上、中間及右下寫上 Z，然後把撲克牌 A 的鬼牌移除。將撲克牌 A 的 52 張牌加上撲克牌 B 的 Z 和 N 就製作完成啦。

block script
  script.
    const vm = new Vue({ // eslint-disable-line
      el: '#app',
      data: {
        i: {
          page: 'setting',
          players: [],
          roundCur: 0,
        },
      },
      async mounted () {
        try {
          const saved = JSON.parse(localStorage.getItem('boardgame-wizard'))
          if (saved) this.$set(this, 'i', { ...this.i, ...saved })
        } catch (err) {}
        this.$watch('i', (newVal, oldVal) => {
          localStorage.setItem('boardgame-wizard', JSON.stringify(this.i))
        }, { deep: true })
      },
      computed: {
        roundMax () {
          if (!_.inRange(this.i.players.length, 3, 7)) return 0
          return 60 / this.i.players.length
        },
        predictsSum () {
          let sum = []
          for (let i=0; i<this.roundMax; i++) {
            sum[i] = _.sumBy(this.i.players, player => _.get(player, ['rounds', i, 'predict'], 0))
          }
          return sum
        },
        resultsSum () {
          let sum = []
          for (let i=0; i<this.roundMax; i++) {
            sum[i] = _.sumBy(this.i.players, player => _.get(player, ['rounds', i, 'result'], 0))
          }
          return sum
        },
        roundsEnable () {
          let ret = []
          for (let i=0; i<this.roundMax; i++) {
            ret[i] = (this.predictsSum[i] + this.resultsSum[i]) > 0
          }
          return ret
        },
        playersScore () {
          return _.map(this.i.players, this.playerScore)
        },
        inputResultColor () {
          return (this.resultsSum[this.i.roundCur] === this.i.roundCur + 1) ? '-success' : '-danger'
        },
        dealer () {
          return this.i.roundCur % this.i.players.length
        },
      },
      methods: {
        async setPlayers (n) {
          if (!_.inRange(n, 3, 7)) return
          const confirm = await Swal.fire({
            cancelButtonColor: '#3085d6',
            cancelButtonText: '保持原樣',
            confirmButtonColor: '#d33',
            confirmButtonText: '開啟新局',
            icon: 'warning',
            showCancelButton: true,
            text: `是否開始一個全新的 ${n} 人遊戲？`,
          })
          if (!confirm.value) return
          this.$set(this.i, 'players', _.times(n, i => ({
            name: _.get(this, `i.players.${i}.name`, `${i+1}P`),
            rounds: _.times(60 / n, () => ({ predict: 0, result: 0 })),
          })))
          this.i.roundCur = 0
        },
        calculatePlayerRoundScore (round) {
          let predict = _.get(round, 'predict', 0)
          let result = _.get(round, 'result', 0)
          if (predict === result) return result * 10 + 20
          return Math.abs(result - predict) * -10
        },
        playerScore (player) {
          let sum = 0
          _.each(player.rounds, (round, i) => {
            if (this.resultsSum[i] <= 0) return
            sum += this.calculatePlayerRoundScore(round)
          })
          return sum
        },
        playerSwapWithNext(playerId) {
          const players = this.i.players
          if (playerId < 0 || playerId > players.length - 2) return
          players.splice(playerId, 2, players[playerId+1], players[playerId])
        },
      },
    })